\documentclass{article}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{inconsolata}
\usepackage{enumerate}
\usepackage{verbatim}
\usepackage{hyperref}
\usepackage[parfill]{parskip}
\usepackage[margin = 2.5cm]{geometry}

\usepackage[T1]{fontenc}


\begin{document}

\title{Lab 4.1: Validating Data in Models\\ IN705 Databases Three}
\date{}
\maketitle

\section*{Introduction}
In our database application, our model classes have two important responsibilities.  First, they read data from and save data to our data store as appropriate.  Second, they \emph{validate} data entered to be sure that we do not save any invalid data in our data store.  

\textbf{It is extremely important that we never save invalid information in our databases.}\footnote{Although we will see later that we sometime relax this requirement in certain deliberate and carefully managed ways.}

Through ActiveRecord, Ruby on Rails provides a set of methods that facilitate data validation in our models.  You can read about these at \url{http://guides.rubyonrails.org/active\_record\_validations.html}.

\section{Validating our users}
We store the following items of data for each of our users:

\begin{itemize}
 \item name
 \item email address
 \item password
 \item blurb
\end{itemize}

Let's enforce the following constraints on our model:
\begin{itemize}
 \item name: must not be empty
 \item email address: must be unique, i.e., no two users have the same email address
 \item password: must be at least 8 characters long
\end{itemize}

We will do this by using \emph{Active Record Validations} in our User class.

To require a value in the name field, add the following line to the User class;

\texttt{validates :name, presence: true}

To enforce uniqueness for email addresses, add the following:


\texttt{validates :email, uniqueness: true }

The problem with this is that you can get around it by varying the case of the supplied email address.  To prevent that, do the following:

\texttt{validates :email, uniqueness: \{ case\_sensitive: false\}  }

\newpage

To enforce our length requirement on passwords, add the following:

\texttt{validates :password, length: \{minimum: 8\} } 

\section{Explicitly controlling validations}
Suppose we want to enforce a password policy that includes, in addition to a minimum length, some additional requirements like the mixed-case or the use of a special character.  We need to write our own validation method.  There are a few ways to do this, but one example is the following:

\begin{verbatim}
 validates :password, length: {minimum: 8}, if: :strong?

 def strong?
    password =~ /.*\d+.*/ && \
    password =~ /.*[a-z]+.*/ && \
    password =~ /.*[A-Z].*/
 end

\end{verbatim}

With this code, the password validates only if the length is at least 8 characters and if the \texttt{strong?} method returns \texttt{true}.

\section{Conclusion}
Using the methods here or others that you find on the linked web page, perform appropriate validations on your User and Splatt models.
\end{document}
